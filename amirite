/*
 *           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *                   Version 2, December 2004
 *
 *           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *  0. You just DO WHAT THE FUCK YOU WANT TO.
 *********************************************************************/

#ifndef _AMIRITE_H
#define _AMIRITE_H

#include <iostream>
#include <sstream>
#include <type_traits>
#include <typeinfo>
#include <map>
#include <vector>
#include <string>
#include <functional>
#include <algorithm>
#include <stdexcept>

namespace inspect
{
#	if defined(__clang__) || defined(__GNUC__) && !defined(NO_DEMANGLE)
#		include <cxxabi.h>

		template <typename Type>
		inline
		std::string
		type (void)
		{
			std::string result;
			int         status;
			char*       demangled = abi::__cxa_demangle(typeid(Type).name(),
			                                              nullptr, nullptr, &status);

			result = demangled;
			free(demangled);

			if (std::is_enum<Type>::value) {
				result = "enum " + result;
			}
			else if (std::is_union<Type>::value) {
				result = "union " + result;
			}

			return result;
		}
#	elif defined(_MSC_VER) && !defined(NO_DEMANGLE)
#		include <Windows.h>
#		include <Dbghelp.h>

		template <typename Type>
		inline
		std::string
		type (void)
		{
			char demangled[4096];
			UnDecorateSymbolName(typeid(Type).name(), demangled, 4096,
				UNDNAME_COMPLETE);

			return demangled;
		}
#	else
		template <typename Type>
		inline
		std::string
		type (void)
		{
			return typeid(Type).name();
		}
#	endif

	namespace _has_cout
	{
		typedef char no[1];
		typedef char yes[2];

		struct any
		{
			template <typename T>
			any (T const&);
		};

		no& operator << (std::ostream const&, any const&);

		yes& test (std::ostream&);
		no&  test (no&);

		template <typename Type>
		struct has_cout
		{
			static std::ostream& s;
			static Type const& t;

			enum : bool {
				value = sizeof(test(s << t)) == sizeof(yes)
			};
		};
	}

	template <typename Type>
	struct has_cout : _has_cout::has_cout<Type>
	{};

	template <typename Type, class Enable = void>
	struct has_to_string_method;

	template <typename Type>
	struct has_to_string_method<Type,
		typename std::enable_if<std::is_class<Type>::value>::type>
	{
		typedef char no[1];
		typedef char yes[2];

		template <typename T, T>
		struct type_check;

		template <class T>
		struct to_string
		{
			typedef std::string (T::*function)(void);
		};

		template <class T>
		static
		yes& test (type_check<typename to_string<T>::function, &T::to_string>*);

		template <class T>
		static no& test (...);

		enum : bool {
			value = sizeof(test<Type>(0)) == sizeof(yes)
		};
	};

	template <typename Type>
	struct has_to_string_method<Type,
		typename std::enable_if<!std::is_class<Type>::value>::type>
	{
		enum : bool {
			value = false
		};
	};

	template <typename Type, class Enable = void>
	struct has_inspect_method;

	template <typename Type>
	struct has_inspect_method<Type,
		typename std::enable_if<std::is_class<Type>::value>::type>
	{
		typedef char no[1];
		typedef char yes[2];

		template <typename T, T>
		struct type_check;

		template <class T>
		struct inspect
		{
			typedef std::string (T::*function)(void);
		};

		template <class T>
		static
		yes& test (type_check<typename inspect<T>::function, &T::inspect>*);

		template <class T>
		static no& test (...);

		enum : bool {
			value = sizeof(test<Type>(0)) == sizeof(yes)
		};
	};

	template <typename Type>
	struct has_inspect_method<Type,
		typename std::enable_if<!std::is_class<Type>::value>::type>
	{
		enum : bool {
			value = false
		};
	};

	template <typename Type>
	struct is_string
	{
		enum : bool {
			value = std::is_same<Type, std::string>::value ||
		                             std::is_same<Type, std::wstring>::value ||
		                             std::is_same<Type, std::u16string>::value ||
		                             std::is_same<Type, std::u32string>::value
		};
	};

	template <typename Type>
	struct is_raw_string
	{
		enum : bool {
			value = (std::is_array<Type>::value &&
				std::is_same<typename std::remove_const<
					typename std::remove_extent<Type>::type>::type, char>::value) ||

				(std::is_pointer<Type>::value &&
					std::is_same<typename std::remove_const<
						typename std::remove_pointer<Type>::type>::type, char>::value)
		};
	};

	template <typename Type>
	inline
	typename std::enable_if<is_string<Type>::value, Type>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);

		ss << "\"";
		for (auto ch : value) {
			if (ch == '\\') {
				ss << "\\";
			}

			ss << ch;
		}
		ss << "\"";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<is_raw_string<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);

		ss << "\"";
		for (char const* string = value; *string; string++) {
			if (*string == '\\') {
				ss << "\\";
			}

			ss << *string;
		}
		ss << "\"";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_fundamental<Type>::value, std::string>::type
	value (Type value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << std::boolalpha << value;

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_pointer<Type>::value &&
		!is_raw_string<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "(" << type<Type>() << ") 0x" << std::hex << (intptr_t) value;

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_enum<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_enum<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ": " <<
			static_cast<typename std::underlying_type<Type>::type>(value) << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_union<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_union<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ":" << &value << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_class<Type>::value &&
		!is_string<Type>::value &&
		!has_to_string_method<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_class<Type>::value &&
		!is_string<Type>::value &&
		!has_to_string_method<Type>::value &&
		!has_inspect_method<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ":" << &value << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<has_to_string_method<Type>::value &&
		!has_inspect_method<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);
		ss << "#<" << type<Type>() << ": " << value.to_string() << ">";

		return ss.str();
	}

	template <typename Type>
	inline
	typename std::enable_if<has_inspect_method<Type>::value, std::string>::type
	value (Type& value)
	{
		return value.inspect();
	}

	template <typename Type>
	inline
	typename std::enable_if<std::is_array<Type>::value &&
		!is_raw_string<Type>::value, std::string>::type
	value (Type& value)
	{
		std::ostringstream ss(std::ostringstream::out);

		ss << "[";
		for (unsigned i = 0; i < std::extent<Type>::value; i++) {
			ss << inspect::value(value[i]);

			if (i < std::extent<Type>::value - 1) {
				ss << ", ";
			}
		}
		ss << "]";

		return ss.str();
	}
}

namespace ami
{
	struct location
	{
		unsigned    line;
		std::string file;

		location (void)
		{
			line = 0;
			file = "";
		}

		location (unsigned l, std::string f)
		{
			line = l;
			file = f;
		}

		bool
		empty (void) const
		{
			return line == 0 && file.empty();
		}
	};

	class test
	{
		public:
			class exception : public std::runtime_error
			{
				public:
					explicit exception (void) : std::runtime_error("test passed") { }

					explicit exception (std::string const& what_arg) : std::runtime_error(what_arg) { }
					explicit exception (char const* what_arg) : std::runtime_error(what_arg) { }

					explicit exception (std::string const& what_arg, std::string const& info, struct location const& location) : std::runtime_error(what_arg)
					{
						_info     = info;
						_location = location;
					}

					std::string
					info (void)
					{
						return _info;
					}

					location const&
					location (void)
					{
						return _location;
					}

				private:
					std::string     _info;
					struct location _location;
			};

			class success : public exception
			{
				public:
					explicit success (void) : exception("test passed") { }
					explicit success (std::string const& what_arg) : exception(what_arg) { }
					explicit success (char const* what_arg) : exception(what_arg) { }
					explicit success (std::string const& what_arg, std::string const& info, struct location const& location) : exception(what_arg, info, location) { }
			};

			class failure : public exception
			{
				public:
					explicit failure (void) : exception("test passed") { }
					explicit failure (std::string const& what_arg) : exception(what_arg) { }
					explicit failure (char const* what_arg) : exception(what_arg) { }
					explicit failure (std::string const& what_arg, std::string const& info, struct location const& location) : exception(what_arg, info, location) { }
			};

			class skip : public exception
			{
				public:
					explicit skip (void) : exception("test passed") { }
					explicit skip (std::string const& what_arg) : exception(what_arg) { }
					explicit skip (char const* what_arg) : exception(what_arg) { }
					explicit skip (std::string const& what_arg, std::string const& info, struct location const& location) : exception(what_arg, info, location) { }
			};

		public:
			test (std::string name, std::function<void(void)> check)
			{
				_name  = name;
				_check = check;

				_result = nullptr;
			}

			~test (void)
			{
				if (_result) {
					delete _result;
				}
			}

			std::string
			name (void)
			{
				return _name;
			}

			std::string
			message (void)
			{
				return _result ? _result->what() : "";
			}

			std::string
			info (void)
			{
				return _result ? _result->info() : "";
			}

			bool
			run (void)
			{
				if (_result) {
					return false;
				}

				try {
					_check();

					_result = new success();
				}
				catch (success& e) {
					_result = new success(e);
				}
				catch (failure& e) {
					_result = new failure(e);
				}
				catch (skip& e) {
					_result = new skip(e);
				}

				return true;
			}

			bool
			passed (void)
			{
				return dynamic_cast<success*>(_result) != nullptr;
			}

			bool
			failed (void)
			{
				return dynamic_cast<failure*>(_result) != nullptr;
			}

			bool
			skipped (void)
			{
				return dynamic_cast<skip*>(_result) != nullptr;
			}

			const struct location
			location (void)
			{
				struct location result;

				if (_result) {
					result = _result->location();
				}

				return result;
			}

		private:
			std::string               _name;
			std::function<void(void)> _check;

			exception* _result;
	};

	class suite
	{
		public:
			suite (std::string name)
			{
				_name = name;
			}

			suite (std::string name, std::map<std::string, std::function<void(void)>> tests) : suite(name)
			{
				add(tests);
			}

			suite (void) : suite("")
			{}

			suite (std::map<std::string, std::function<void(void)>> tests) : suite("", tests)
			{}

			std::string
			name (void)
			{
				return _name;
			}

			bool
			anonymous (void)
			{
				return _name.empty();
			}

			suite&
			add (std::map<std::string, std::function<void(void)>> tests)
			{
				for (auto entry : tests) {
					add(test(entry.first, entry.second));
				}

				return *this;
			}

			test&
			add (test test)
			{
				_tests.push_back(test);

				return _tests.back();
			}

			suite&
			run (void)
			{
				for (auto& test : _tests) {
					test.run();
				}

				return *this;
			}

			bool
			passed (void)
			{
				return std::none_of(begin(), end(), [](test& test) {
					return test.failed();
				});
			}

			std::vector<test>::iterator
			begin (void)
			{
				return _tests.begin();
			}

			std::vector<test>::iterator
			end (void)
			{
				return _tests.end();
			}

		private:
			std::string       _name;
			std::vector<test> _tests;
	};

	namespace printer
	{
		void
		prelude (suite& s)
		{
			if (s.anonymous()) {
				std::cout << "Running tests: ";
			}
			else {
				std::cout << "Running tests in " << s.name() << ": ";
			}
		}

		void
		dots (test& t)
		{
			t.run();

			if (t.passed()) {
				std::cout << ".";
			}
			else if (t.failed()) {
				std::cout << "E";
			}
			else if (t.skipped()) {
				std::cout << "S";
			}
		}
	}

	void
	skip (void)
	{
		throw test::skip();
	}

	void
	skip (std::string reason, std::string info = "", location loc = {})
	{
		throw test::skip(reason, info, loc);
	}

	void
	fail (void)
	{
		throw test::failure();
	}

	void
	fail (std::string reason, std::string info = "", location loc = {})
	{
		throw test::failure(reason, info, loc);
	}

	void
	pass (void)
	{
		throw test::success();
	}

	void
	pass (std::string reason, std::string info = "", location loc = {})
	{
		throw test::success(reason, info, loc);
	}

	template <typename Type>
	void
	truthy (Type value, std::string info = "", location loc = {})
	{
		if (!value) {
			fail("expected a truthy value, got " + inspect::value(value) + " instead", info, loc);
		}
	}

#	define _amitruthy1(value) \
		ami::truthy(value, "", ami::location(__LINE__, __FILE__))

#	define _amitruthy2(value, info) \
		ami::truthy(value, info, ami::location(__LINE__, __FILE__))

#	define _amitruthy(_, _1, _2, selected, ...) \
		selected

#	define amitruthy(...) \
		_amitruthy(, ## __VA_ARGS__, \
		             _amitruthy2(__VA_ARGS__), \
		             _amitruthy1(__VA_ARGS__))

	template <typename Type>
	void
	falsy (Type value, std::string info = "", location loc = {})
	{
		if (value) {
			fail("expected a falsy value, got " + inspect::value(value) + " instead", info, loc);
		}
	}

#	define _amifalsy1(value) \
		ami::falsy(value, "", ami::location(__LINE__, __FILE__))

#	define _amifalsy2(value, info) \
		ami::falsy(value, info, ami::location(__LINE__, __FILE__))

#	define _amifalsy(_, _1, _2, selected, ...) \
		selected

#	define amifalsy(...) \
		_amifalsy(, ## __VA_ARGS__, \
		             _amifalsy2(__VA_ARGS__), \
		             _amifalsy1(__VA_ARGS__))

	template <typename First, typename Second>
	void
	equal (First first, Second second, std::string info = "", location loc = {})
	{
		if (first != second) {
			fail("expected " + inspect::value(first) + " and " + inspect::value(second) + " to be equal", info, loc);
		}
	}

#	define _amiequal2(first, second) \
		ami::equal(first, second, "", ami::location(__LINE__, __FILE__))

#	define _amiequal3(first, second, info) \
		ami::equal(first, second, info, ami::location(__LINE__, __FILE__))

#	define _amiequal(_, _1, _2, _3, selected, ...) \
		selected

#	define amiequal(...) \
		_amiequal(, ## __VA_ARGS__, \
		             _amiequal3(__VA_ARGS__), \
		             _amiequal2(__VA_ARGS__))

	template <typename First, typename Second>
	void
	different (First first, Second second, std::string info = "", location loc = {})
	{
		if (first == second) {
			fail("expected " + inspect::value(first) + " and " + inspect::value(second) + " to be different", info, loc);
		}
	}

#	define _amidifferent2(first, second) \
		ami::different(first, second, "", ami::location(__LINE__, __FILE__))

#	define _amidifferent3(first, second, info) \
		ami::different(first, second, info, ami::location(__LINE__, __FILE__))

#	define _amidifferent(_, _1, _2, _3, selected, ...) \
		selected

#	define amidifferent(...) \
		_amidifferent(, ## __VA_ARGS__, \
		             _amidifferent3(__VA_ARGS__), \
		             _amidifferent2(__VA_ARGS__))

	template <class Exception>
	void
	thrown (std::function<void(void)> check)
	{
		try {
			check();

			fail("expected " + inspect::type<Exception>() + " to be thrown, but nothing was");
		}
		catch (std::exception& e) {
			if (dynamic_cast<Exception*>(e) == nullptr) {
				fail("expected " + inspect::type<Exception>() + " to be thrown, but something else was");
			}
		}
	}

	template <class Exception>
	void
	thrown (std::string info, std::function<void(void)> check)
	{
		try {
			check();

			fail("expected " + inspect::type<Exception>() + " to be thrown, but nothing was", info);
		}
		catch (std::exception& e) {
			if (dynamic_cast<Exception*>(e) == nullptr) {
				fail("expected " + inspect::type<Exception>() + " to be thrown, but something else was", info);
			}
		}
	}
}

int
amirite (ami::suite suite)
{
	suite.run();

	for (auto& test : suite) {
		if (test.failed()) {
			std::cout << suite.name() << "/" << test.name();
			if (!test.location().empty()) {
				std::cout << " (" << test.location().file << ":" << test.location().line << ")";
			}
			std::cout << std::endl;

			std::cout << test.message();
			if (!test.info().empty()) {
				std::cout << " (" << test.info() << ")";
			}
			std::cout << std::endl;

			std::cout << std::endl;
		}
	}

	return suite.passed() ? 0 : 1;
}

int
amirite (std::string name, std::map<std::string, std::function<void(void)>> tests)
{
	ami::suite suite(name, tests);

	return amirite(suite);
}

int
amirite (std::function<void(ami::suite&)> setup, std::function<void(ami::test&)> each, std::map<std::string, std::function<void(void)>> tests)
{
	ami::suite suite(tests);

	setup(suite);

	for (auto& test : suite) {
		each(test);
	}

	std::cout << std::endl;

	return suite.passed() ? 0 : 1;
}

int
amirite (std::function<void(ami::suite&)> setup, std::function<void(ami::test&)> each, std::string name, std::map<std::string, std::function<void(void)>> tests)
{
	ami::suite suite(name, tests);

	setup(suite);

	for (auto& test : suite) {
		each(test);
	}

	std::cout << std::endl;

	return suite.passed() ? 0 : 1;
}

#endif
